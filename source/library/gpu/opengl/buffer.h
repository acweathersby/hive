#pragma once

#ifdef HIVE_USE_OPENGL


#include "gpu/opengl/glwrap.h"
#include "primitive/log.h"
#include <GL/gl.h>


namespace hive
{

    using namespace gl;

    struct VRAMBuffer : SmartGLint {

      protected:
        unsigned buffer_size = 0;

        unsigned short BOUND_TO = 0;

        GLenum usage;

        bool MAPPED = false;

        virtual void deleteUnderlyingGLResource() override;

      public:
        VRAMBuffer(GLenum usage = GL_STATIC_DRAW) : SmartGLint(SmartGLType::Buffer), usage(usage)
        {

            glCreateBuffers(1, (GLuint *)(&pointer));

            GLenum error = glGetError();

            IS_READY = (error == GL_NO_ERROR && pointer != 0);

//############################## DEBUG
#ifdef HIVE_DEBUG

            switch (error) {

            case GL_INVALID_VALUE:
                // is generated if n is negative.

                __ERROR("Number of buffers to create cannot be negative");
                break;
            }

//############################## END DEBUG
#endif
        };


        ~VRAMBuffer() { decreaseReferenceCount(); }

        VRAMBuffer(const VRAMBuffer & obj) : SmartGLint(obj)
        {
            buffer_size = obj.buffer_size;
            BOUND_TO    = obj.BOUND_TO;
            usage       = obj.usage;
        }

        void setData(void *, unsigned int = 0, unsigned int = 0);

        void use(SKGLB);


        /**
         * Binds buffer data to an indexed range of GLSL elements.
         *
         * https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml
         *
         *- target
         *
         * Specify the target of the bind operation. target must be one of
         * GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or
         * GL_SHADER_STORAGE_BUFFER. index Specify the index of the binding point within
         * the array specified by target.
         *
         *- offset
         *
         * The starting offset in basic machine units into the buffer object buffer.
         *
         *- size
         *
         * The amount of data in machine units that can be read from the buffer object
         * while used as an indexed target.
         *
         * -------------------------------------------
         *
         * Notes:
         *
         * The GL_ATOMIC_COUNTER_BUFFER target is available only if the GL version is 4.2 or
         * greater.
         *
         * The GL_SHADER_STORAGE_BUFFER target is available only if the GL version is 4.3 or
         * greater.
         */

        void useRange(const SKGLB buffer_binding, unsigned index, unsigned offset, unsigned size);
        /**
         * Bind buffer to an indexed buffer target.
         *
         * binding_point is the index of the binding point used
         *
         * SKGLB should be one of:
         *     ATOMIC_COUNTER_BUFFER
         *     SHADER_STORAGE_BUFFER
         *     TRANSFORM_FEEDBACK_BUFFER
         *     UNIFORM_BUFFER
         */
        void useBase(const SKGLB buffer_binding, unsigned binding_point);

        virtual void release() override;

        inline bool DATA_LOADED() { return buffer_size > 0; }

        inline unsigned size() { return buffer_size; }

        inline void * GPU_Pointer(unsigned size, GLbitfield bf)
        {
            MAPPED = true;

            glMapBufferRange(pointer, 1024, 0, bf);

            void * p = glMapNamedBufferRange(pointer, 0, 1024, bf);

            if (p == NULL) {
                throw("Unable to acquire direct mapped gl buffer.");

                return NULL;


                GLenum error = glGetError();

                if (error != GL_NO_ERROR) IS_READY = false;

//############################## DEBUG
#ifdef HIVE_DEBUG

                switch (error) {
                case GL_INVALID_ENUM:
                    // is generated by glMapBufferRange if target is not one of the buffer
                    // binding targets listed above.

                    __ERROR("Buffer target not valid.");
                    break;


                case GL_INVALID_VALUE:
                    /**
                     *   is generated if offset or length is negative, if offset+length is
                     *   greater than the value of GL_BUFFER_SIZE for the buffer object, or if
                     *     access has any bits set other than those defined above.
                     */

                    __ERROR("Mapped buffer size is negative, or data is larger than buffer "
                            "size, or data is too dirty.");
                    break;

                case GL_INVALID_OPERATION:

                    /**
                     * is generated by glMapNamedBufferRange if buffer is not the name of an
                     * existing buffer object.
                     *
                     * is generated by glMapBufferRange if zero is bound to target.
                     *
                     *   is generated for any of the following conditions:
                     *
                     *   length is zero.
                     *
                     *   The buffer object is already in a mapped state.
                     *
                     *   Neither GL_MAP_READ_BIT nor GL_MAP_WRITE_BIT is set.
                     *
                     *   GL_MAP_READ_BIT is set and any of GL_MAP_INVALIDATE_RANGE_BIT,
                     *   GL_MAP_INVALIDATE_BUFFER_BIT or GL_MAP_UNSYNCHRONIZED_BIT is set.
                     *
                     *   GL_MAP_FLUSH_EXPLICIT_BIT is set and GL_MAP_WRITE_BIT is not set.
                     *
                     *   Any of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, or
                     *   GL_MAP_COHERENT_BIT are set, but the same bit is not included in the
                     *   buffer's storage flags.
                     */


                    __ERROR("Invalid use of buffer object: Either buffer name is 0, buffer "
                            "name\n"
                            "does not exist, or buffer is immutable.");
                    break;
                }

//############################## END DEBUG
#endif
            } // namespace gl

            return p;
        } // namespace hive
    };

    void VRAMBuffer::deleteUnderlyingGLResource() { glDeleteBuffers(1, (GLuint *)(&pointer)); }

    inline void VRAMBuffer::useBase(const SKGLB buffer_binding, unsigned binding_point)
    {

//############################## DEBUG
#ifdef HIVE_DEBUG
        if (!IS_READY) {
            //  __ERROR("GL buffer is not ready to use.", 0, "buffer.cpp", __LINE__);
            return; // throw error
        }

        clearErrors();

//############################## END DEBUG
#endif

        switch (buffer_binding) {

        case (SKGLB::ATOMIC_COUNTER_BUFFER):
            if (SKGL_ATOMIC_COUNTER_BUFFER_SET != pointer) {
                SKGL_ATOMIC_COUNTER_BUFFER_SET = pointer;
                glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, binding_point, pointer);
                BOUND_TO |= SKGLB::ATOMIC_COUNTER_BUFFER;
            }
            break;

        case (SKGLB::SHADER_STORAGE_BUFFER):
            if (SKGL_SHADER_STORAGE_BUFFER_SET != pointer) {
                SKGL_SHADER_STORAGE_BUFFER_SET = pointer;
                glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding_point, pointer);
                BOUND_TO |= SKGLB::SHADER_STORAGE_BUFFER;
            }
            break;

        case (SKGLB::TRANSFORM_FEEDBACK_BUFFER):
            if (SKGL_TRANSFORM_FEEDBACK_BUFFER_SET != pointer) {
                SKGL_TRANSFORM_FEEDBACK_BUFFER_SET = pointer;
                glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, binding_point, pointer);
                BOUND_TO |= SKGLB::TRANSFORM_FEEDBACK_BUFFER;
            }
            break;

        case (SKGLB::UNIFORM_BUFFER):
            if (SKGL_UNIFORM_BUFFER_SET != pointer) {
                SKGL_UNIFORM_BUFFER_SET = pointer;
                glBindBufferBase(GL_UNIFORM_BUFFER, binding_point, pointer);
                BOUND_TO |= SKGLB::UNIFORM_BUFFER;
            }
            break;
        default:

            IS_READY = false;

//############################## DEBUG
#ifdef HIVE_DEBUG
            __ERROR("Buffer target not valid for this operation.");

//############################## END DEBUG
#endif

            return;
        }


//############################## DEBUG
#ifdef HIVE_DEBUG

        GLenum error = glGetError();

        if (error != GL_NO_ERROR) IS_READY = false;

        switch (error) {
        case GL_INVALID_ENUM:
            // GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER,
            // GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
            __ERROR("Buffer target not valid. Needs to be one of GL_ATOMIC_COUNTER_BUFFER,"
                    " GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or "
                    "GL_SHADER_STORAGE_BUFFER.");
            break;


        case GL_INVALID_VALUE:
            // GL_INVALID_VALUE is generated if index is greater than or equal to the number of
            // target-specific indexed binding points. GL_INVALID_VALUE is generated if buffer
            // does not have an associated data store, or if the size of that store is zero.

            if (buffer_size <= 0) {
                __ERROR("Buffer store is empty.");
            } else {
                __ERROR("Index is out of range");
            }
            break;
        }

//############################## END DEBUG
#endif
    }

    void VRAMBuffer::useRange(const SKGLB buffer_binding, unsigned index, unsigned offset,
                              unsigned size)
    {

//############################## DEBUG
#ifdef HIVE_DEBUG
        if (!IS_READY) {
            //__ERROR("GL buffer is not ready to use.", 0, "buffer.cpp", __LINE__);
            return; // throw error
        }
//############################## END DEBUG
#endif

        switch (buffer_binding) {

        case (SKGLB::ATOMIC_COUNTER_BUFFER):
            if (SKGL_ATOMIC_COUNTER_BUFFER_SET != pointer) use(ATOMIC_COUNTER_BUFFER);

            glBindBufferRange(GL_ATOMIC_COUNTER_BUFFER, index, pointer, offset, size);
            break;

        case (SKGLB::SHADER_STORAGE_BUFFER):
            if (SKGL_SHADER_STORAGE_BUFFER_SET != pointer) use(SHADER_STORAGE_BUFFER);

            glBindBufferRange(GL_SHADER_STORAGE_BUFFER, index, pointer, offset, size);
            break;

        case (SKGLB::TRANSFORM_FEEDBACK_BUFFER):
            if (SKGL_TRANSFORM_FEEDBACK_BUFFER_SET != pointer) use(TRANSFORM_FEEDBACK_BUFFER);

            glBindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER, index, pointer, offset, size);
            break;

        case (SKGLB::UNIFORM_BUFFER):
            if (SKGL_UNIFORM_BUFFER_SET != pointer) use(UNIFORM_BUFFER);

            glBindBufferRange(GL_UNIFORM_BUFFER, index, pointer, offset, size);
            break;
        default:

            IS_READY = false;

//############################## DEBUG
#ifdef HIVE_DEBUG
            __ERROR("Buffer target not valid for this operation.");

//############################## END DEBUG
#endif

            return;
        }

//############################## DEBUG
#ifdef HIVE_DEBUG


        GLenum error = glGetError();

        if (error != GL_NO_ERROR) IS_READY = false;

        switch (error) {
        case GL_INVALID_ENUM:
            // GL_INVALID_ENUM is generated if target is not one of GL_ATOMIC_COUNTER_BUFFER,
            // GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.

            __ERROR("Buffer target not valid.");
            break;


        case GL_INVALID_VALUE:

            // GL_INVALID_VALUE is generated if index is greater than or equal to the number of
            // target-specific indexed binding points.

            // GL_INVALID_VALUE is generated if size is less than or equal to zero, or if offset
            // + size is greater than the value of GL_BUFFER_SIZE.
            if (size <= 0) {
                __ERROR("Size is less than or equal to zero.");
            } else if (size + offset > buffer_size) {
                __ERROR("Buffer size" + std::to_string(buffer_size) +
                        "  is smaller than the range: " + std::to_string(offset) +
                        "to: " + std::to_string(size + offset));
            } else {
                int alignment = 0;

                switch (buffer_binding) {

                case (SKGLB::SHADER_STORAGE_BUFFER):
                    glGetIntegerv(GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT, &alignment);
                    break;

                case (SKGLB::UNIFORM_BUFFER):
                    glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &alignment);
                    break;
                default:
                    break;
                }

                if (offset % alignment && alignment > 0) {
                    __ERROR("Offset alignment is incorrect, alignment should be on " +
                            std::to_string(alignment) + " aligned boundaries.");
                } else {

                    __ERROR("Index is is greater or equal to the number of target specified "
                            "binding points");
                }
            }

            break;
        }

//############################## END DEBUG
#endif
    }

    inline void VRAMBuffer::use(const SKGLB buffer_binding)
    {

//############################## DEBUG
#ifdef HIVE_DEBUG
        if (!IS_READY) {
            __ERROR("GL buffer is not ready to use.", 0, "buffer.cpp", __LINE__);
            return; // throw error
        }

        clearErrors();
//############################## END DEBUG
#endif

        switch (buffer_binding) {
        case (SKGLB::ARRAY_BUFFER):
            if (SKGL_ARRAY_BUFFER_SET != pointer) {
                SKGL_ARRAY_BUFFER_SET = pointer;
                glBindBuffer(GL_ARRAY_BUFFER, pointer);
                BOUND_TO |= SKGLB::ARRAY_BUFFER;
            }
            break;

        case (SKGLB::ATOMIC_COUNTER_BUFFER):
            if (SKGL_ATOMIC_COUNTER_BUFFER_SET != pointer) {
                SKGL_ATOMIC_COUNTER_BUFFER_SET = pointer;
                glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, pointer);
                BOUND_TO |= SKGLB::ATOMIC_COUNTER_BUFFER;
            }
            break;

        case (SKGLB::COPY_READ_BUFFER):
            if (SKGL_COPY_READ_BUFFER_SET != pointer) {
                SKGL_COPY_READ_BUFFER_SET = pointer;
                glBindBuffer(GL_COPY_READ_BUFFER, pointer);
                BOUND_TO |= SKGLB::COPY_READ_BUFFER;
            }
            break;

        case (SKGLB::COPY_WRITE_BUFFER):
            if (SKGL_COPY_WRITE_BUFFER_SET != pointer) {
                SKGL_COPY_WRITE_BUFFER_SET = pointer;
                glBindBuffer(GL_COPY_WRITE_BUFFER, pointer);
                BOUND_TO |= SKGLB::COPY_WRITE_BUFFER;
            }
            break;

        case (SKGLB::DISPATCH_INDIRECT_BUFFER):
            if (SKGL_DISPATCH_INDIRECT_BUFFER_SET != pointer) {
                SKGL_DISPATCH_INDIRECT_BUFFER_SET = pointer;
                glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, pointer);
                BOUND_TO |= SKGLB::DISPATCH_INDIRECT_BUFFER;
            }
            break;

        case (SKGLB::DRAW_INDIRECT_BUFFER):
            if (SKGL_DRAW_INDIRECT_BUFFER_SET != pointer) {
                SKGL_DRAW_INDIRECT_BUFFER_SET = pointer;
                glBindBuffer(GL_DRAW_INDIRECT_BUFFER, pointer);
                BOUND_TO |= SKGLB::DRAW_INDIRECT_BUFFER;
            }
            break;

        case (SKGLB::ELEMENT_ARRAY_BUFFER):
            if (SKGL_ELEMENT_ARRAY_BUFFER_SET != pointer) {
                SKGL_ELEMENT_ARRAY_BUFFER_SET = pointer;
                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, pointer);
                BOUND_TO |= SKGLB::ELEMENT_ARRAY_BUFFER;
            }
            break;

        case (SKGLB::PIXEL_PACK_BUFFER):
            if (SKGL_PIXEL_PACK_BUFFER_SET != pointer) {
                SKGL_PIXEL_PACK_BUFFER_SET = pointer;
                glBindBuffer(GL_PIXEL_PACK_BUFFER, pointer);
                BOUND_TO |= SKGLB::PIXEL_PACK_BUFFER;
            }
            break;

        case (SKGLB::PIXEL_UNPACK_BUFFER):
            if (SKGL_PIXEL_UNPACK_BUFFER_SET != pointer) {
                SKGL_PIXEL_UNPACK_BUFFER_SET = pointer;
                glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pointer);
                BOUND_TO |= SKGLB::PIXEL_UNPACK_BUFFER;
            }
            break;

        case (SKGLB::QUERY_BUFFER):
            if (SKGL_QUERY_BUFFER_SET != pointer) {
                SKGL_QUERY_BUFFER_SET = pointer;
                glBindBuffer(GL_QUERY_BUFFER, pointer);
                BOUND_TO |= SKGLB::QUERY_BUFFER;
            }
            break;

        case (SKGLB::SHADER_STORAGE_BUFFER):
            if (SKGL_SHADER_STORAGE_BUFFER_SET != pointer) {
                SKGL_SHADER_STORAGE_BUFFER_SET = pointer;
                glBindBuffer(GL_SHADER_STORAGE_BUFFER, pointer);
                BOUND_TO |= SKGLB::SHADER_STORAGE_BUFFER;
            }
            break;

        case (SKGLB::TEXTURE_BUFFER):
            if (SKGL_TEXTURE_BUFFER_SET != pointer) {
                SKGL_TEXTURE_BUFFER_SET = pointer;
                glBindBuffer(GL_TEXTURE_BUFFER, pointer);
                BOUND_TO |= SKGLB::TEXTURE_BUFFER;
            }
            break;

        case (SKGLB::TRANSFORM_FEEDBACK_BUFFER):
            if (SKGL_TRANSFORM_FEEDBACK_BUFFER_SET != pointer) {
                SKGL_TRANSFORM_FEEDBACK_BUFFER_SET = pointer;
                glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, pointer);
                BOUND_TO |= SKGLB::TRANSFORM_FEEDBACK_BUFFER;
            }
            break;

        case (SKGLB::UNIFORM_BUFFER):
            if (SKGL_UNIFORM_BUFFER_SET != pointer) {
                SKGL_UNIFORM_BUFFER_SET = pointer;
                glBindBuffer(GL_UNIFORM_BUFFER, pointer);
                BOUND_TO |= SKGLB::UNIFORM_BUFFER;
            }
            break;
        }


#ifdef HIVE_DEBUG //############################## DEBUG
        GLenum error = glGetError();

        if (error != GL_NO_ERROR) IS_READY = false;

        switch (error) {
        case GL_INVALID_ENUM:
            // is generated by glBufferData if target is not one of the
            // accepted buffer targets.

            // is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ,
            // GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY,
            // GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.

            __ERROR("Buffer target not valid.");
            break;


        case GL_INVALID_VALUE:
            // is generated if buffer is not a name previously returned from a call to
            // glGenBuffers.


            __ERROR("Buffer name is not valid.");
            break;
        }

//############################## END DEBUG
#endif
    }

    void VRAMBuffer::release() {}

    /**
     * Loads buffer data using glNamedBufferData if data has not been previously
     * set, or glNamedBufferSubData if the buffer already contains data.
     *
     * Reads and reports gl errors HIVE_DEBUG mode.
     */
    void VRAMBuffer::setData(void * data, unsigned int size, unsigned int offset)
    {

//############################## DEBUG
#ifdef HIVE_DEBUG
        if (!IS_READY) {
            //__ERROR("GL buffer is not ready to use.", 0, "buffer.cpp", __LINE__);
            return; // throw error
        }

        clearErrors();
//############################## END DEBUG
#endif

        if (buffer_size == 0 || buffer_size < size + offset) {
            glNamedBufferData(pointer, size, data, usage);
            buffer_size = size + offset;
        } else {
            glNamedBufferSubData(pointer, offset, size, data);
        }

//############################## DEBUG
#ifdef HIVE_DEBUG
        GLenum error = glGetError();
        if (error != GL_NO_ERROR) IS_READY = false;

        switch (error) {
        case GL_INVALID_ENUM:
            // is generated by glBufferData if target is not one of the
            // accepted buffer targets.

            // is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ,
            // GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY,
            // GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.

            __ERROR("Buffer target not valid.");
            break;


        case GL_INVALID_VALUE:
            // is generated if size is negative.

            __ERROR("Size of buffer cannot be negative");
            break;

        case GL_INVALID_OPERATION:
            // is generated by glBufferData if the reserved buffer object
            // name 0 is bound to target.

            // is generated by glNamedBufferData if buffer is not the
            // name of an existing buffer object.

            // is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of
            // the buffer object is GL_TRUE.

            __ERROR("Invalid use of buffer object: Either buffer name is 0, buffer name\n"
                    "does not exist, or buffer is immutable.");
            break;

        case GL_OUT_OF_MEMORY:
            // is generated if the GL is unable to create a data store with
            // the specified size.

            __ERROR("Size of buffer cannot be negative");
            break;
        }

//############################## END DEBUG
#endif
    }
} // namespace hive

#endif