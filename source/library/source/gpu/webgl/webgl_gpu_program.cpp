#include "include/hive.h"
#include <sys/types.h>

namespace hive
{
    GLuint createShader(const char * shader_str, const int shader_str_length, GLenum shader_type,
                        const std::string info_label)
    {
        GLuint shader = glCreateShader(shader_type);

        if (shader > 0) { // Must be a non-zero value


            glShaderSource(shader, 1, &shader_str, &shader_str_length);

            glCompileShader(shader);

            // Checkout the shader bro!
            int result, info_length;

            glGetShaderiv(shader, GL_COMPILE_STATUS, &result);

            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_length);

            std::vector<char> shader_log(info_length > 1 ? info_length : 1);

            glGetShaderInfoLog(shader, info_length, NULL, &shader_log[0]);

            if (result == GL_TRUE) {
                DEBUG_META(__LOG("Compiled " + info_label));
            } else {
                DEBUG_META(__LOG("" + info_label + " failed to load \n "); __LOG(&shader_log[0]);)
            }
        } else {
            DEBUG_META(__LOG("Failed to generate " + info_label));
        }

        return shader;
    };

    void reportShaderProgramErrors(int program)
    {
        int err = glGetError();

        int result, info_length;

        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_length);

        std::vector<char> shader_log(info_length > 1 ? info_length : 1);

        glGetProgramInfoLog(program, info_length, NULL, &shader_log[0]);

        DEBUG_META(__LOG("Program failed to load \n "); __LOG(&shader_log[0]);)

        do {
            // TODO - Make this more informative.
            __LOG("GL_INVALID_VALUE is generated if either program or shader is not a value "
                  "generated by OpenGL.\n"
                  "GL_INVALID_OPERATION is generated if program is not a program object.\n"
                  "GL_INVALID_OPERATION is generated if shader is not a shader object.\n"
                  "GL_INVALID_OPERATION is generated if shader is already attached to "
                  "program.\n");

            err = glGetError();
        } while (err);
    };

    void configureProgramInterfaces(GLint program, ShaderProgramPropData & data)
    {


        std::vector<ShaderArtifact> artifacts;

        const size_t string_buffer_size = 50;
        int written_length              = 0;

        char name[string_buffer_size];

        int number_of_elements = 0, attrib_size = 0;

        GLenum attrib_type = 0;

        // Inputs ------------------------------------------------------

        // Attributes ------

        glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &number_of_elements);

        for (int attrib_index = 0; attrib_index < number_of_elements; attrib_index++) {
            glGetActiveAttrib(program, attrib_index, string_buffer_size, &written_length,
                              &attrib_size, &attrib_type, name);

            ShaderArtifact artifact = {

                // interface_type
                ShaderArtifact::ArtifactType::DataInput,

                // element_type
                (ShaderArtifact::ElementType)getGLSLTypePrimitive(attrib_type),

                // element_size - scalar or vector or matrix or custom
                (int)getGLSLTypeElementCount(attrib_size),

                // byte size
                (int)getGLSLTypeSize(attrib_type),

                // array_size
                attrib_size,

                // shader location
                attrib_index,

                // short_name
                StringHash64(name, written_length)};


            artifacts.push_back(artifact);
        }

        // Uniforms -----

        int uniform_size    = 0;
        GLenum uniform_type = 0;

        glGetProgramiv(program, GL_ACTIVE_UNIFORMS, &number_of_elements);

        std::cout << "number of uniforms " << number_of_elements << std::endl;

        for (int uniform_index = 0; uniform_index < number_of_elements; uniform_index++) {

            glGetActiveUniform(program, uniform_index, string_buffer_size, &written_length,
                               &uniform_size, &uniform_type, name);

            ShaderArtifact artifact = {

                // interface_type
                ShaderArtifact::ArtifactType::DataInput,

                // element_type
                (ShaderArtifact::ElementType)getGLSLTypePrimitive(uniform_type),

                // element_size - scalar or vector or matrix or custom
                (int)getGLSLTypeElementCount(uniform_size),

                // byte size
                (int)getGLSLTypeSize(uniform_type),

                // array_size
                uniform_size,

                // shader location
                uniform_index,

                // short_name
                StringHash64(name, written_length)};

            auto d = StringHash64(name, written_length);

            artifacts.push_back(artifact);
        }

        data.artifacts = artifacts;
    }


    ShaderProgramProp::ShaderProgramProp() : Prop("PROP_GPU_PROGRAM", sizeof(ShaderProgramProp)) {}

    ShaderProgramProp::~ShaderProgramProp() {}

    bool ShaderProgramProp::fromString(const std::string string_data)
    {


        char const *vert = nullptr, *frag = nullptr;

        char const * string = string_data.data();

        unsigned vert_str_size = 0, frag_str_size = 0, state = 0;

        const char frag_name[8] = "[frag]\n", vert_name[8] = "[vert]\n";

        for (int i = 0; i < string_data.size(); i++) {

            const char d = string[i];

            switch (state & 0x3) {

            case 0:
                if (d == '[') state = 1;
                break;

            case 1:
                if (d == 'f' && frag_str_size == 0)
                    state = 3 | 8;
                else if (d == 'v' && frag_str_size == 0)
                    state = 2 | 8;
                else
                    state = 0;
                break;
            case 2: {

                const unsigned char char_pos = state >> 2;

                if (d == vert_name[char_pos])
                    state += 4;
                else
                    state = 0;

                if (char_pos >= 7) {

                    vert = string + i;

                    state = 0;

                    if (frag != nullptr && frag_str_size == 0)
                        frag_str_size = ((string + i) - frag) - 7;
                }
            } break;

            case 3: {

                const unsigned char char_pos = state >> 2;

                if (d == frag_name[char_pos])
                    state += 4;
                else
                    state = 0;

                if (char_pos >= 7) {

                    frag = string + i;

                    state = 0;

                    if (vert != nullptr && vert_str_size == 0) {
                        vert_str_size = (i - (vert - string)) - 7;
                    }
                }
            } break;
            }
        }

        if (vert != nullptr && vert_str_size == 0)
            vert_str_size = string_data.size() - (vert - string);

        if (frag != nullptr && frag_str_size == 0)
            frag_str_size = string_data.size() - (frag - string);

        if (vert_str_size > 0 && frag_str_size > 0) {

            GLint program = glCreateProgram();

            if (program > 0) {

                GLint vert_shader =
                    createShader(vert, vert_str_size, GL_VERTEX_SHADER, "vert shader");

                GLint frag_shader =
                    createShader(frag, frag_str_size, GL_FRAGMENT_SHADER, "frag shader");

                if (vert_shader > 0 && frag_shader > 0) {

                    glAttachShader(program, vert_shader);
                    glAttachShader(program, frag_shader);

                    // Link our program
                    glLinkProgram(program);

                    int result;

                    // Get the compiled status
                    glGetProgramiv(program, GL_LINK_STATUS, &result);

                    if (result == GL_TRUE) {

                        glUseProgram(program);

                        glDetachShader(program, vert_shader);
                        glDetachShader(program, frag_shader);

                        glDeleteShader(vert_shader);
                        glDeleteShader(frag_shader);

                        // Create data

                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        // Program Boss should control allocation and release of
                        // ShaderProgramPropData !!!!!!!!!!!!!!
                        // Need check for ability to dedup this.

#warning "Program Boss should control allocation and release of ShaderProgramPropData"

                        data = new ShaderProgramPropData;

                        data->program = program;

                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                        configureProgramInterfaces(program, *data);

                        return true;
                    }

                    DEBUG_META(reportShaderProgramErrors(program));
                    // clearErrors();
                    glDeleteProgram(program);
                }
            }
        }

        return false;
    } // namespace hive

    bool ShaderProgramProp::fromBinary(const char * buffer, const unsigned buffer_size)
    {
        std::cout << "Unable to create WebGL program from binary data. Must describe program using "
                     "ASCII encoded chara data with the [fromString] command"
                  << std::endl;
        return false;
    }

    bool ShaderProgramProp::IS_AVAILABLE_ON_GPU()
    {
        if (data == nullptr) return false;
        if (data->program == 0) return false;
        return true;
    }

    const std::vector<ShaderArtifact> & ShaderProgramProp::getInputMap()
    {
        if (data == nullptr) throw "Shader Program Not Initialized";
        if (data->artifacts.size() == 0) throw "Shader Program Not Initialized";
        return data->artifacts;
    }

    const std::vector<ShaderArtifact> & ShaderProgramProp::getOutputMap()
    {
        if (data == nullptr) throw "Shader Program Not Initialized";
        if (data->artifacts.size() == 0) throw "Shader Program Not Initialized";
        return data->artifacts;
    }
} // namespace hive
