#pragma once

#include <vector>

#include "primitive/shader_program.hpp"

#include "gpu/opengl/gl.hpp"
#include "gpu/opengl/glwrap.hpp"

namespace hive
{

    GLuint createShader(const char * shader_str, const int shader_str_length, GLenum shader_type,
                        const std::string info_label)
    {
        GLuint shader = glCreateShader(shader_type);

        if (shader > 0) { // Must be a non-zero value


            glShaderSource(shader, 1, &shader_str, &shader_str_length);

            glCompileShader(shader);

            // Checkout the shader bro!
            int result, info_length;

            glGetShaderiv(shader, GL_COMPILE_STATUS, &result);

            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_length);

            std::vector<char> shader_log(info_length > 1 ? info_length : 1);

            glGetShaderInfoLog(shader, info_length, NULL, &shader_log[0]);

            if (result == GL_TRUE) {
                DEBUG_META(__LOG("Compiled " + info_label));
            } else {
                DEBUG_META(__LOG("" + info_label + " failed to load \n "); __LOG(&shader_log[0]);)
            }
        } else {
            DEBUG_META(__LOG("Failed to generate " + info_label));
        }

        return shader;
    };

    void reportShaderProgramErrors(int program)
    {
        int err = glGetError();

        int result, info_length;

        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_length);

        std::vector<char> shader_log(info_length > 1 ? info_length : 1);

        glGetProgramInfoLog(program, info_length, NULL, &shader_log[0]);

        DEBUG_META(__LOG("Program failed to load \n "); __LOG(&shader_log[0]);)

        do {
            // TODO - Make this more informative.
            __LOG("GL_INVALID_VALUE is generated if either program or shader is not a value "
                  "generated by OpenGL.\n"
                  "GL_INVALID_OPERATION is generated if program is not a program object.\n"
                  "GL_INVALID_OPERATION is generated if shader is not a shader object.\n"
                  "GL_INVALID_OPERATION is generated if shader is already attached to "
                  "program.\n");

            err = glGetError();
        } while (err);
    };

    void ShaderProgramProp::configureProgramInterfaces()
    {
        auto data      = getData<ShaderProgramPropData>();
        auto programs  = data->programs;
        auto & program = data->program;

        // loadProgramObjects
        int count, name_length;

        std::vector<ShaderArtifact> artifacts;

        char name[50];

        // Inputs ------------------------------------------------------

        glGetProgramInterfaceiv(program, GL_PROGRAM_INPUT, GL_ACTIVE_RESOURCES, &count);
        glGetProgramInterfaceiv(program, GL_PROGRAM_INPUT, GL_MAX_NAME_LENGTH, &name_length);

        for (int i = 0; i < count; i++) {

            glGetProgramResourceName(program, GL_PROGRAM_INPUT, i, 50, &name_length, name);

            std::string name_string(name);

            const unsigned int properties[] = {
                GL_TYPE,                              // int
                GL_ARRAY_SIZE,                        // int
                GL_LOCATION,                          // int
                GL_LOCATION_COMPONENT,                // int
                GL_REFERENCED_BY_VERTEX_SHADER,       // int = 1 | 0
                GL_REFERENCED_BY_COMPUTE_SHADER,      // int = 1 | 0
                GL_REFERENCED_BY_TESS_CONTROL_SHADER, // int = 1 | 0
                GL_REFERENCED_BY_GEOMETRY_SHADER,     // int = 1 | 0
                GL_REFERENCED_BY_FRAGMENT_SHADER,     // int = 1 | 0
            };

            const int prop_count = sizeof(properties) >> 2;
            int actual;
            int vals[prop_count];

            glGetProgramResourceiv(program, GL_PROGRAM_INPUT, i, prop_count, properties, prop_count,
                                   &actual, vals);


            ShaderArtifact artifact = {
                ShaderArtifact::ArtifactType::DataInput,                    // interface_type
                (ShaderArtifact::ElementType)getGLSLTypePrimitive(vals[0]), // element_type
                (int)getGLSLTypeElementCount(
                    vals[0]), // element_size - scalar or vector or matrix or custom
                (int)getGLSLTypeSize(vals[0]), // byte_size
                vals[1],                       // array_size
                vals[2],                       // shader location
                (vals[4] << 0) | (vals[5] << 2) | (vals[6] << 4) | (vals[7] << 8) |
                    (vals[8] << 16)};

            artifacts.push_back(artifact);
        }

        // Uniforms ------------------------------------------------------

        glGetProgramInterfaceiv(program, GL_UNIFORM, GL_ACTIVE_RESOURCES, &count);
        glGetProgramInterfaceiv(program, GL_UNIFORM, GL_MAX_NAME_LENGTH, &name_length);

        for (int i = 0; i < count; i++) {

            glGetProgramResourceName(program, GL_PROGRAM_INPUT, i, 50, &name_length, name);

            std::string name_string(name);

            const unsigned int properties[] = {
                GL_TYPE,                                 // int
                GL_ARRAY_SIZE,                           // int
                GL_LOCATION,                             // int
                GL_OFFSET,                               // int
                GL_REFERENCED_BY_VERTEX_SHADER,          // int 0 | 1
                GL_REFERENCED_BY_TESS_CONTROL_SHADER,    // int 0 | 1
                GL_REFERENCED_BY_TESS_EVALUATION_SHADER, // int 0 | 1
                GL_REFERENCED_BY_GEOMETRY_SHADER,        // int 0 | 1
                GL_REFERENCED_BY_FRAGMENT_SHADER,        // int 0 | 1
                GL_REFERENCED_BY_COMPUTE_SHADER,         // int 0 | 1
                GL_BLOCK_INDEX,                          // int
                GL_ARRAY_STRIDE,                         // int
                GL_MATRIX_STRIDE,                        // int
                GL_IS_ROW_MAJOR,                         // int
            };

            const int prop_count = sizeof(properties) >> 2;
            int actual;
            int vals[prop_count];

            glGetProgramResourceiv(program, GL_PROGRAM_INPUT, i, prop_count, properties, prop_count,
                                   &actual, vals);

            ShaderArtifact artifact = {
                ShaderArtifact::ArtifactType::Uniform,                      // interface_type
                (ShaderArtifact::ElementType)getGLSLTypePrimitive(vals[0]), // element_type
                (int)getGLSLTypeElementCount(
                    vals[0]), // element_size - scalar or vector or matrix or custom
                (int)getGLSLTypeSize(vals[0]), // byte_size
                vals[1],                       // array_size
                vals[2],                       // shader location
                (vals[4] << 0) | (vals[5] << 2) | (vals[6] << 4) | (vals[7] << 8) |
                    (vals[8] << 16)};
            artifacts.push_back(artifact);
        }

        // Uniform Blocks ------------------------------------------------------

        glGetProgramInterfaceiv(program, GL_UNIFORM_BLOCK, GL_ACTIVE_RESOURCES, &count);
        glGetProgramInterfaceiv(program, GL_UNIFORM_BLOCK, GL_MAX_NAME_LENGTH, &name_length);

        for (int i = 0; i < count; i++) {

            glGetProgramResourceName(program, GL_PROGRAM_INPUT, i, 50, &name_length, name);

            std::string name_string(name);

            const unsigned int properties[] = {
                GL_BUFFER_BINDING,
                GL_BUFFER_DATA_SIZE,
                GL_REFERENCED_BY_VERTEX_SHADER,
                GL_REFERENCED_BY_TESS_CONTROL_SHADER,
                GL_REFERENCED_BY_TESS_EVALUATION_SHADER,
                GL_REFERENCED_BY_GEOMETRY_SHADER,
                GL_REFERENCED_BY_FRAGMENT_SHADER,
                GL_REFERENCED_BY_COMPUTE_SHADER,
                GL_NUM_ACTIVE_VARIABLES,
                GL_ACTIVE_VARIABLES,
            };

            const int prop_count = sizeof(properties) >> 2;

            int actual;

            int vals[prop_count];

            glGetProgramResourceiv(program, GL_PROGRAM_INPUT, i, prop_count, properties, prop_count,
                                   &actual, vals);

            ShaderArtifact artifact = {ShaderArtifact::ArtifactType::UniformBlock, // interface_type
                                       ShaderArtifact::ElementType::STRUCT,        // element_type
                                       1, // element_size - scalar or vector or matrix or custom
                                       vals[1], // byte_size
                                       1,       // array_size
                                       vals[0], // shader location
                                       (vals[2] << 0) | (vals[3] << 2) | (vals[4] << 4) |
                                           (vals[5] << 8) | (vals[6] << 16)};

            artifacts.push_back(artifact);
        }

        // Outputs ------------------------------------------------------

        glGetProgramInterfaceiv(program, GL_PROGRAM_OUTPUT, GL_ACTIVE_RESOURCES, &count);
        glGetProgramInterfaceiv(program, GL_PROGRAM_OUTPUT, GL_MAX_NAME_LENGTH, &name_length);

        for (int i = 0; i < count; i++) {

            glGetProgramResourceName(program, GL_PROGRAM_OUTPUT, i, 50, &name_length, name);

            std::string name_string(name);

            const unsigned int properties[] = {
                GL_TYPE,                              // int
                GL_ARRAY_SIZE,                        // int
                GL_LOCATION,                          // int
                GL_LOCATION_COMPONENT,                // int
                GL_REFERENCED_BY_VERTEX_SHADER,       // int = 1 | 0
                GL_REFERENCED_BY_COMPUTE_SHADER,      // int = 1 | 0
                GL_REFERENCED_BY_TESS_CONTROL_SHADER, // int = 1 | 0
                GL_REFERENCED_BY_GEOMETRY_SHADER,     // int = 1 | 0
                GL_REFERENCED_BY_FRAGMENT_SHADER,     // int = 1 | 0
                GL_LOCATION_INDEX,
            };

            const int prop_count = sizeof(properties) >> 2;
            int actual;
            int vals[prop_count];

            glGetProgramResourceiv(program, GL_PROGRAM_OUTPUT, i, prop_count, properties,
                                   prop_count, &actual, vals);

            ShaderArtifact artifact = {
                ShaderArtifact::ArtifactType::DataOutput,                   // interface_type
                (ShaderArtifact::ElementType)getGLSLTypePrimitive(vals[0]), // element_type
                (int)getGLSLTypeElementCount(
                    vals[0]), // element_size - scalar or vector or matrix or custom
                (int)getGLSLTypeSize(vals[0]), // byte_size
                vals[1],                       // array_size
                vals[2] | vals[8] << 16,       // shader location | index location
                (vals[4] << 0) | (vals[5] << 2) | (vals[6] << 4) | (vals[7] << 8) |
                    (vals[8] << 16)};

            artifacts.push_back(artifact);
        }

        data->artifacts = artifacts;

        // temp
    }

    bool ShaderProgramProp::compileShader()
    {
        auto data      = getData<ShaderProgramPropData>();
        auto programs  = data->programs;
        auto & program = data->program;

        program = glCreateProgram();

        if (programs[ShaderProgramIndices::COMPUTE_SHADER] > 0)
            glAttachShader(program, programs[ShaderProgramIndices::COMPUTE_SHADER]);
        else {
            if (programs[ShaderProgramIndices::VERTEX_SHADER] > 0)
                glAttachShader(program, programs[ShaderProgramIndices::VERTEX_SHADER]);

            if (programs[ShaderProgramIndices::FRAGMENT_SHADER] > 0)
                glAttachShader(program, programs[ShaderProgramIndices::FRAGMENT_SHADER]);

            if (programs[ShaderProgramIndices::GEOMETRY_SHADER] > 0)
                glAttachShader(program, programs[ShaderProgramIndices::GEOMETRY_SHADER]);

            if (programs[ShaderProgramIndices::TESSELATION_CTRL_SHADER] > 0)
                glAttachShader(program, programs[ShaderProgramIndices::TESSELATION_CTRL_SHADER]);

            if (programs[ShaderProgramIndices::TESSELATION_EVAL_SHADER] > 0)
                glAttachShader(program, programs[ShaderProgramIndices::TESSELATION_EVAL_SHADER]);
        }

        // Link our program
        glLinkProgram(program);

        int result;

        // Get the compiled status
        glGetProgramiv(program, GL_LINK_STATUS, &result);

        if (result == GL_TRUE) {

            glUseProgram(program);

            // Shaders do not need to be attached to the program anymore

            if (programs[ShaderProgramIndices::COMPUTE_SHADER] > 0)
                glDetachShader(program, programs[ShaderProgramIndices::COMPUTE_SHADER]);
            if (programs[ShaderProgramIndices::VERTEX_SHADER] > 0)
                glDetachShader(program, programs[ShaderProgramIndices::VERTEX_SHADER]);
            if (programs[ShaderProgramIndices::FRAGMENT_SHADER] > 0)
                glDetachShader(program, programs[ShaderProgramIndices::FRAGMENT_SHADER]);
            if (programs[ShaderProgramIndices::GEOMETRY_SHADER] > 0)
                glDetachShader(program, programs[ShaderProgramIndices::GEOMETRY_SHADER]);
            if (programs[ShaderProgramIndices::TESSELATION_CTRL_SHADER] > 0)
                glDetachShader(program, programs[ShaderProgramIndices::TESSELATION_CTRL_SHADER]);
            if (programs[ShaderProgramIndices::TESSELATION_EVAL_SHADER] > 0)
                glDetachShader(program, programs[ShaderProgramIndices::TESSELATION_EVAL_SHADER]);

            configureProgramInterfaces();

        } else {
            // pullup any error
            DEBUG_META(reportShaderProgramErrors(program));
            clearErrors();
            glDeleteProgram(program);
            program = 0;
            return false;
        }

        return true;
    };

    bool ShaderProgramProp::deleteShaders()
    {
        auto data = getData<ShaderProgramPropData>();

        if (!data) return false;

        auto programs = data->programs;

        if (programs[ShaderProgramIndices::COMPUTE_SHADER] > 0)
            glDeleteShader(programs[ShaderProgramIndices::COMPUTE_SHADER]);
        if (programs[ShaderProgramIndices::VERTEX_SHADER] > 0)
            glDeleteShader(programs[ShaderProgramIndices::VERTEX_SHADER]);
        if (programs[ShaderProgramIndices::FRAGMENT_SHADER] > 0)
            glDeleteShader(programs[ShaderProgramIndices::FRAGMENT_SHADER]);
        if (programs[ShaderProgramIndices::GEOMETRY_SHADER] > 0)
            glDeleteShader(programs[ShaderProgramIndices::GEOMETRY_SHADER]);
        if (programs[ShaderProgramIndices::TESSELATION_CTRL_SHADER] > 0)
            glDeleteShader(programs[ShaderProgramIndices::TESSELATION_CTRL_SHADER]);
        if (programs[ShaderProgramIndices::TESSELATION_EVAL_SHADER] > 0)
            glDeleteShader(programs[ShaderProgramIndices::TESSELATION_EVAL_SHADER]);

        return true;
    }

    bool ShaderProgramProp::addVertexShader(std::string & vertex_shader_string)
    {
        int shader = createShader(vertex_shader_string, GL_VERTEX_SHADER, "vertex shader");

        if (shader == 0) return false;

        getData<ShaderProgramPropData>()->programs[ShaderProgramIndices::VERTEX_SHADER] = shader;

        return true;
    };

    bool ShaderProgramProp::addFragShader(std::string & frag_shader_string)
    {
        int shader = createShader(frag_shader_string, GL_FRAGMENT_SHADER, "frag shader");

        if (shader == 0) return false;

        getData<ShaderProgramPropData>()->programs[ShaderProgramIndices::FRAGMENT_SHADER] = shader;

        return true;
    };

    bool ShaderProgramProp::addComputeShader(std::string & compute_shader_string)
    {
        int shader = createShader(compute_shader_string, GL_COMPUTE_SHADER, "compute shader");

        if (shader == 0) return false;

        getData<ShaderProgramPropData>()->programs[ShaderProgramIndices::COMPUTE_SHADER] = shader;

        return true;
    };

    bool ShaderProgramProp::addGeometryShader(std::string & geometry_shader_string)
    {
        int shader = createShader(geometry_shader_string, GL_GEOMETRY_SHADER, "geometry shader");

        if (shader == 0) return false;

        getData<ShaderProgramPropData>()->programs[ShaderProgramIndices::GEOMETRY_SHADER] = shader;

        return true;
    };

    bool ShaderProgramProp::addTesselationEvalShader(std::string & tesselation_eval_shader)
    {
        int shader = createShader(tesselation_eval_shader, GL_VERTEX_SHADER, "vertex shader");

        if (shader == 0) return false;

        getData<ShaderProgramPropData>()->programs[ShaderProgramIndices::COMPUTE_SHADER] = shader;

        return true;
    };

    bool ShaderProgramProp::addTesselationControlShader(std::string & tesselation_ctrl_shader)
    {
        int shader = createShader(tesselation_ctrl_shader, GL_VERTEX_SHADER, "vertex shader");

        if (shader == 0) return false;

        getData<ShaderProgramPropData>()->programs[ShaderProgramIndices::COMPUTE_SHADER] = shader;

        return true;
    };

    // bool addVertexShader(std::string & vertex_shader_string) {}
    // bool addFragShader(std::string & vertex_shader_string) {}
    // bool addComputeShader(std::string & vertex_shader_string) {}
    // bool addGeometryShader(std::string & vertex_shader_string) {}
    // bool addTexelShader(std::string & vertex_shader_string) {}
    // void removeVertex();

} // namespace hive