#include "include/hive.h"

#include <sys/types.h>

namespace hive
{
    GLuint createShader(const char * shader_str, const int shader_str_length, GLenum shader_type,
                        const std::string info_label)
    {

        std::cout << std::string(shader_str, shader_str_length) << std::endl;
        GLuint shader = glCreateShader(shader_type);

        if (shader > 0) { // Must be a non-zero value

            glShaderSource(shader, 1, &shader_str, &shader_str_length);

            glCompileShader(shader);

            // Checkout the shader bro!
            int result, info_length;

            glGetShaderiv(shader, GL_COMPILE_STATUS, &result);

            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_length);

            std::vector<char> shader_log(info_length > 1 ? info_length : 1);

            glGetShaderInfoLog(shader, info_length, NULL, &shader_log[0]);

            if (result == GL_TRUE) {
                DEBUG_META(__LOG("Compiled " + info_label));
            } else {
                DEBUG_META(__LOG("" + info_label + " failed to load \n "); __LOG(&shader_log[0]);)
            }
        } else {
            DEBUG_META(__LOG("Failed to generate " + info_label));
        }

        return shader;
    };

    void reportShaderProgramErrors(int program)
    {
        int err = glGetError(), info_length;

        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_length);

        std::vector<char> shader_log(info_length > 1 ? info_length : 1);

        glGetProgramInfoLog(program, info_length, NULL, &shader_log[0]);

        DEBUG_META(__LOG("Program failed to load \n "); __LOG(&shader_log[0]);)

        do {
            // TODO - Make this more informative.
            __LOG("GL_INVALID_VALUE is generated if either program or shader is not a value "
                  "generated by OpenGL.\n"
                  "GL_INVALID_OPERATION is generated if program is not a program object.\n"
                  "GL_INVALID_OPERATION is generated if shader is not a shader object.\n"
                  "GL_INVALID_OPERATION is generated if shader is already attached to "
                  "program.\n");

            err = glGetError();
        } while (err);
    };

    void configureProgramInterfaces(GLint program, GPUProgramDataField::PTR data)
    {


        std::vector<ShaderArtifact> artifacts;

        const size_t string_buffer_size = 50;
        int written_length              = 0;

        char name[string_buffer_size];

        int number_of_elements = 0, attrib_size = 0;

        GLenum attrib_type = 0;

        // Inputs ------------------------------------------------------

        // Attributes ------

        glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, &number_of_elements);

        for (int attrib_index = 0; attrib_index < number_of_elements; attrib_index++) {

            glGetActiveAttrib(program, attrib_index, string_buffer_size, &written_length,
                              &attrib_size, &attrib_type, name);

            GLint attribute_location = glGetAttribLocation(program, name);

            ShaderArtifact artifact = {

                // interface_type
                ShaderArtifact::ArtifactType::VertexData,

                // element_type
                (ShaderArtifact::ElementPrimitiveType)getGLSLTypePrimitive(attrib_type),

                // element_size - scalar or vector or matrix or custom
                (int)getGLSLTypeElementCount(attrib_type),

                // byte size
                (int)getGLSLTypeSize(attrib_type),

                // array_size
                attrib_size,

                // shader location
                attribute_location,

                // short_name
                StringHash64(name, written_length)};


            artifacts.push_back(artifact);
        }

        // Uniforms -----

        int uniform_size    = 0;
        GLenum uniform_type = 0;

        glGetProgramiv(program, GL_ACTIVE_UNIFORMS, &number_of_elements);

        std::cout << "number of uniforms " << number_of_elements << std::endl;

        for (int uniform_index = 0; uniform_index < number_of_elements; uniform_index++) {

            glGetActiveUniform(program, uniform_index, string_buffer_size, &written_length,
                               &uniform_size, &uniform_type, name);

            GLint uniform_location = glGetUniformLocation(program, name);

            ShaderArtifact::ArtifactType type;

            if (isUniformTypeSampler(uniform_type)) {
                type = getGLSLSamplerArtifactType(uniform_type);
            } else {
                type = ShaderArtifact::ArtifactType::Uniform;
            }

            ShaderArtifact artifact = {

                // interface_type
                type,

                // element_type
                (ShaderArtifact::ElementPrimitiveType)getGLSLTypePrimitive(uniform_type),

                // element_size - scalar or vector or matrix or custom
                (int)getGLSLTypeElementCount(uniform_size),

                // byte size
                (int)getGLSLTypeSize(uniform_type),

                // array_size
                uniform_size,

                // shader location
                uniform_location,

                // short_name
                StringHash64(name, written_length)};

            auto d = StringHash64(name, written_length);

            artifacts.push_back(artifact);
        }

        data->artifacts = artifacts;
    }

    ShaderProgramProp::ShaderProgramProp() : Prop() {}

    ShaderProgramProp::~ShaderProgramProp() {}

    struct ShaderStringPTR {
        const char * string = nullptr;
        unsigned size       = 0;
    };

    struct ShaderStages {
        ShaderStringPTR vert;
        ShaderStringPTR frag;
        ShaderStringPTR geom;
        ShaderStringPTR eval;
        ShaderStringPTR tess;
        ShaderStringPTR comp;
    };

    bool ShaderProgramProp::fromString(const std::string string_data)
    {

        ShaderStages stages = {{nullptr, 0}, {nullptr, 0}, {nullptr, 0},
                               {nullptr, 0}, {nullptr, 0}, {nullptr, 0}};

        ShaderStringPTR * stageptr = &stages.vert;

        constexpr unsigned number_of_shader_stages  = 6;
        constexpr unsigned shader_stage_flag_length = 8;

        constexpr char stage_names[number_of_shader_stages][shader_stage_flag_length] = {
            "[vert]\n", "[frag]\n", "[geom]\n", "[eval]\n", "[tess]\n", "[comp]\n"};

        char const * string = string_data.data();

        int i = 0, current_stage_index = -1, pending_stage_index = -1, parse_name_index = 0,
            parse_start = 0;

        bool IS_PARSING_SHADER_STAGE = false;

        while (i < string_data.size()) {

            const char d = string[i++];

            if (d == '[' && i < string_data.size()) {

                const char c = string[i];

                unsigned j = 0;

                for (; j < number_of_shader_stages; j++)
                    if (c == stage_names[j][1]) break;

                if (j < number_of_shader_stages) {
                    pending_stage_index = j;
                    parse_name_index    = 2;
                    i++;
                    continue;
                }
            }

            if (pending_stage_index > -1) {
                if (d == stage_names[pending_stage_index][parse_name_index]) {
                    if (++parse_name_index ==
                        (shader_stage_flag_length - 1) /*omit null terminator*/) {

                        if (IS_PARSING_SHADER_STAGE)
                            stageptr[current_stage_index] = {&string[parse_start],
                                                             (i - (shader_stage_flag_length - 1)) -
                                                                 parse_start};

                        IS_PARSING_SHADER_STAGE = true;
                        parse_start             = i;
                        current_stage_index     = pending_stage_index;
                        pending_stage_index     = -1;
                        continue;
                    }
                } else {
                    pending_stage_index = -1;
                }
            }
        }

        if (IS_PARSING_SHADER_STAGE)
            stageptr[current_stage_index] = {&string[parse_start],
                                             (unsigned)(string_data.size() - parse_start)};

        if (stages.vert.string || stages.frag.string || stages.geom.string || stages.eval.string ||
            stages.tess.string || stages.comp.string) {

            GLint program     = glCreateProgram();
            GLint comp_shader = 0;
            GLint vert_shader = 0;
            GLint frag_shader = 0;
            GLint geom_shader = 0;
            GLint tess_shader = 0;
            GLint eval_shader = 0;

            if (program > 0) {

                if (stages.vert.string) {
                    vert_shader = createShader(stages.vert.string, stages.vert.size,
                                               GL_VERTEX_SHADER, "vert shader");
                    if (!vert_shader) return false;
                }

                if (stages.frag.string) {
                    frag_shader = createShader(stages.frag.string, stages.frag.size,
                                               GL_FRAGMENT_SHADER, "frag shader");
                    if (!frag_shader) return false;
                }

                if (stages.geom.string) {
                    geom_shader = createShader(stages.geom.string, stages.geom.size,
                                               GL_GEOMETRY_SHADER, "geom shader");
                    if (!geom_shader) return false;
                }

                if (stages.tess.string) {
                    tess_shader = createShader(stages.tess.string, stages.tess.size,
                                               GL_TESS_CONTROL_SHADER, "tess shader");
                    if (!tess_shader) return false;
                }

                if (stages.eval.string) {
                    eval_shader = createShader(stages.eval.string, stages.eval.size,
                                               GL_TESS_EVALUATION_SHADER, "eval shader");
                    if (!eval_shader) return false;
                }

                if (stages.comp.string) {
                    comp_shader = createShader(stages.comp.string, stages.comp.size,
                                               GL_COMPUTE_SHADER, "comp shader");
                    if (!comp_shader) return false;
                }

                if (comp_shader) {

                } else {

                    if (vert_shader) glAttachShader(program, vert_shader);
                    if (frag_shader) glAttachShader(program, frag_shader);
                    if (geom_shader) glAttachShader(program, geom_shader);
                    if (tess_shader) glAttachShader(program, tess_shader);
                    if (eval_shader) glAttachShader(program, eval_shader);

                    // Link our program
                    glLinkProgram(program);

                    int result;

                    // Get the compiled status
                    glGetProgramiv(program, GL_LINK_STATUS, &result);

                    if (result == GL_TRUE) {

                        glUseProgram(program);

                        if (vert_shader) glDetachShader(program, vert_shader);
                        if (frag_shader) glDetachShader(program, frag_shader);
                        if (geom_shader) glDetachShader(program, geom_shader);
                        if (tess_shader) glDetachShader(program, tess_shader);
                        if (eval_shader) glDetachShader(program, eval_shader);

                        if (vert_shader) glDeleteShader(vert_shader);
                        if (frag_shader) glDeleteShader(frag_shader);
                        if (geom_shader) glDeleteShader(geom_shader);
                        if (tess_shader) glDeleteShader(tess_shader);
                        if (eval_shader) glDeleteShader(eval_shader);

                        // Possibly output binaries for this shader.

                        // Create data

                        // Program Boss should control allocation and release of
                        // ShaderProgramPropData !!!!!!!!!!!!!!
                        // Need check for ability to dedup this.

                        data = general_data_pool.allocate<ShaderProgramPropData>();

                        data->program = program;

                        configureProgramInterfaces(program, data);

                        return true;
                    }

                    DEBUG_META(reportShaderProgramErrors(program));
                    // clearErrors();
                    glDeleteProgram(program);
                }
            }
        }

        return false;
    } // namespace hive

    bool ShaderProgramProp::fromBinary(const char * buffer, const unsigned buffer_size)
    {
        std::cout << "Unable to create WebGL program from binary data. Must describe program using "
                     "ASCII encoded chara data with the [fromString] command"
                  << std::endl;
        return false;
    }

    bool ShaderProgramProp::IS_AVAILABLE_ON_GPU()
    {
        if (!data) return false;
        if (data->program == 0) return false;
        return true;
    }

    const std::vector<ShaderArtifact> & ShaderProgramProp::getInputMap()
    {
        if (!data) throw "Shader Program Not Initialized";
        if (data->artifacts.size() == 0) throw "Shader Program Not Initialized";
        return data->artifacts;
    }

    const std::vector<ShaderArtifact> & ShaderProgramProp::getOutputMap()
    {
        if (!data) throw "Shader Program Not Initialized";
        if (data->artifacts.size() == 0) throw "Shader Program Not Initialized";
        return data->artifacts;
    }
} // namespace hive
